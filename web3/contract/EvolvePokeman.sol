// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

import {ERC721URIStorage, ERC721} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {Counters} from "@openzeppelin/contracts/utils/Counters.sol";
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

contract EvovlePokeMan is ERC721URIStorage, AutomationCompatibleInterface {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    string[] IpfsUrls = [
        "https://red-just-crab-980.mypinata.cloud/ipfs/QmPVWpzn1Bg8BMpbWMScXLjAkpSFj5D82XQUXrksHQEytd/0",
        "https://red-just-crab-980.mypinata.cloud/ipfs/QmPVWpzn1Bg8BMpbWMScXLjAkpSFj5D82XQUXrksHQEytd/1",
        "https://red-just-crab-980.mypinata.cloud/ipfs/QmPVWpzn1Bg8BMpbWMScXLjAkpSFj5D82XQUXrksHQEytd/2"
    ];
    uint interval;
    uint lastTimeStamp;

    constructor(uint _interval, uint _lastTimeStamp) ERC721("POKEMAN", "PKM") {
        lastTimeStamp = _lastTimeStamp;
        interval = _interval;
    }

    function safeMint(address to) public {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, IpfsUrls[0]);
    }

    function evolvePokeMan(uint256 _tokenId) public {
        uint256 newVal = pokeStage(_tokenId) + 1;
        string memory newURi = IpfsUrls[newVal];
        _setTokenURI(_tokenId, newURi);
    }

    function pokeStage(uint256 _tokenId) public view returns (uint256) {
        string memory _uri = tokenURI(_tokenId);
        if (
            keccak256(abi.encodePacked(_uri)) ==
            keccak256(abi.encodePacked(IpfsUrls[0]))
        ) {
            return 0;
        } else if (
            keccak256(abi.encodePacked(_uri)) ==
            keccak256(abi.encodePacked(IpfsUrls[1]))
        ) {
            return 1;
        } else {
            return 2;
        }
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            uint256 totalTokens = _tokenIdCounter.current();
            for (uint i = 0; i < totalTokens; i++) {
                if (pokeStage(i) < 2) {
                    evolvePokeMan(i);
                }
            }
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}
